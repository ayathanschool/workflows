/**
 * ====== CONFIG ======
 * Replace with your Spreadsheet ID.
 */
const SPREADSHEET_ID = '13wCXKAslpW3JYUguu5R-sWrjcThp1JWIJscwkyMeC8U';

/**
 * ====== Helpers ======
 */
function _ss() {
  try {
    return SpreadsheetApp.openById(SPREADSHEET_ID);
  } catch (err) {
    throw new Error(`Unable to open spreadsheet with ID ${SPREADSHEET_ID}: ${err && err.message ? err.message : err}`);
  }
}

function _getSheet(name) {
  const ss = _ss();
  let sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);
  return sh;
}

function _headers(sh) {
  const range = sh.getRange(1,1,1,sh.getLastColumn() || 1);
  const values = range.getValues()[0];
  return values.map(v => String(v||'').trim());
}

function _ensureHeaders(sh, cols) {
  const h = _headers(sh);
  if (h.filter(Boolean).length === 0) {
    sh.getRange(1,1,1,cols.length).setValues([cols]);
  }
}

function _rows(sh) {
  const lastRow = sh.getLastRow();
  const lastCol = Math.max(sh.getLastColumn(), 1);
  if (lastRow < 2) return [];
  return sh.getRange(2,1,lastRow-2+1,lastCol).getValues();
}

function _indexByHeader(row, headers) {
  const obj = {};
  headers.forEach((h, i) => obj[h] = row[i]);
  return obj;
}

function _uuid() {
  return Utilities.getUuid();
}

function _todayISO() {
  const tz = Session.getScriptTimeZone();
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd}`;
}

function _dayName(isoDate) {
  // Use Utilities.formatDate to compute the day name in the script's timezone
  try {
    const d = new Date(isoDate + 'T00:00:00');
    return Utilities.formatDate(d, Session.getScriptTimeZone(), 'EEEE');
  } catch (e) {
    // Fallback: attempt a simple Date conversion
    const d = new Date(isoDate + 'T00:00:00');
    return d.toLocaleDateString('en-US', { weekday: 'long' });
  }
}

/**
 * Normalize a day name (or abbreviation) to the full English weekday name
 * e.g. 'fri', 'FRIDAY', ' friday ' -> 'Friday'. Returns empty string for falsy input.
 */
function _normalizeDayName(input) {
  if (!input && input !== 0) return '';
  const s = String(input).trim().toLowerCase();
  if (!s) return '';
  const map = {
    'mon': 'Monday', 'monday': 'Monday',
    'tue': 'Tuesday', 'tues': 'Tuesday', 'tuesday': 'Tuesday',
    'wed': 'Wednesday', 'weds': 'Wednesday', 'wednesday': 'Wednesday',
    'thu': 'Thursday', 'thurs': 'Thursday', 'thursday': 'Thursday',
    'fri': 'Friday', 'friday': 'Friday',
    'sat': 'Saturday', 'saturday': 'Saturday',
    'sun': 'Sunday', 'sunday': 'Sunday'
  };
  if (map[s]) return map[s];
  // As a fallback, capitalize first letter of trimmed string
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Determine a grade standard group string for a class name.
 * Examples: "Std 3A" -> "Std 1-4", "10A" -> "Std 9-12".
 * This is a simple heuristic so grade boundaries lookup can select
 * the appropriate group. Returns empty string if unknown.
 */
function _standardGroup(cls) {
  if (!cls) return '';
  try {
    // extract the first number found in the class string
    const m = String(cls).match(/(\d+)/);
    if (!m) return '';
    const n = Number(m[1]);
    if (isNaN(n)) return '';
    if (n <= 4) return 'Std 1-4';
    if (n <= 8) return 'Std 5-8';
    return 'Std 9-12';
  } catch (e) {
    return '';
  }
}

function _respond(obj, status) {
  // ContentService JSON; do not attempt setHeader (not available here).
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function _parsePost(e) {
  try {
    if (e.postData && e.postData.contents) {
      return JSON.parse(e.postData.contents);
    }
  } catch (err) {
    console.error("Error parsing POST data:", err);
  }
  return {};
}

/**
 * ====== Data Model ======
 * Sheets and expected columns
 */
const SHEETS = {
  // NOTE: Added 'password' as third column to align with UserManagement.gs addUser() logic
  Users: ['email','name','password','roles','classes','subjects','classTeacherFor'],
  // Timetable now uses a weekly repeating schedule.  Each row represents
  // a period on a particular day of the week for a specific class and teacher.
  // Columns: class – the class name; dayOfWeek – the day name (e.g. Monday);
  // period – the period number; subject – subject taught; teacherEmail – email
  // address used to match against logged‑in teacher; teacherName – optional
  // display name for reference.  When computing weekly timetables we map the
  // upcoming seven calendar dates to their dayOfWeek and return matching rows.
  Timetable: ['class','dayOfWeek','period','subject','teacherEmail','teacherName'],
  Schemes: ['schemeId','teacherEmail','teacherName','class','subject','term','unit','chapter','month','noOfSessions','status','createdAt'],
  LessonPlans: ['lpId','teacherEmail','teacherName','class','subject','chapter','session','objectives','activities','status','reviewerRemarks','date','createdAt'],
  DailyReports: ['date','teacherEmail','teacherName','class','subject','period','planType','lessonPlanId','chapter','objectives','activities','completed','notes','createdAt'],
  Substitutions: ['date','period','class','absentTeacher','regularSubject','substituteTeacher','substituteSubject','note','createdAt'],
  CalendarEvents: ['eventId','userEmail','title','startTime','endTime','class','subject','notes','type','color','allDay','createdAt']
  ,
  // Exams: metadata for each exam created by the headmaster or authorized staff.
  // Columns: examId – unique ID; creatorEmail – the email of the user who created
  //   the exam; creatorName – the name of the creator; class – the class for which
  //   the exam is conducted; subject – the subject; examType – e.g. Midterm,
  //   Final, Quiz; internalMax – maximum marks for the internal component;
  //   externalMax – maximum marks for the external component; totalMax – the
  //   total marks (internalMax + externalMax); date – the exam date; createdAt –
  //   timestamp of record creation.
  Exams: ['examId','creatorEmail','creatorName','class','subject','examType','internalMax','externalMax','totalMax','date','createdAt'],
  // ExamMarks: stores individual student marks for a given exam.  Columns:
  //   examId – reference to Exams.examId; class – class name; subject – subject;
  //   teacherEmail – email of the teacher submitting marks; teacherName – their name;
  //   admNo – student admission number; studentName – student name;
  //   internal – internal marks scored; external – external marks scored;
  //   total – computed total marks; createdAt – timestamp of record creation.
  ExamMarks: ['examId','class','subject','teacherEmail','teacherName','admNo','studentName','internal','external','total','createdAt']
  ,
  // Students: a master list of students with their admission number, name, class
  // assignment and optional contact details.  This sheet is used to populate
  // class rosters and performance reports.
  Students: ['admNo','name','class','email','parentContact'],
  // GradeTypes: defines exam grading schemes.  Each row specifies the exam type
  // and the maximum internal and external marks as well as the computed total.
  GradeTypes: ['examType','internalMax','externalMax','totalMax'],
  // Attendance: daily attendance records for each student.  Columns store the
  // date, class, student admission number and name, present/absent status,
  // and the teacher who recorded the attendance.
  Attendance: ['date','class','admNo','studentName','status','teacherEmail','teacherName','createdAt']
  ,
  // GradeBoundaries: defines percentage ranges for letter grades per standard group.
  // Each row specifies the standardGroup (e.g. "Std 1-4"), the grade label (e.g. "A"),
  // and the minimum and maximum percentages for that grade.  These ranges are used
  // when computing exam grades from raw marks.
  GradeBoundaries: ['standardGroup','grade','minPercentage','maxPercentage']
};

/**
 * Ensure all tabs exist with headers
 */
function _bootstrapSheets() {
  Object.keys(SHEETS).forEach(name => {
    const sh = _getSheet(name);
    _ensureHeaders(sh, SHEETS[name]);
  });
}

/**
 * ====== Public Web App ======
 */
function doGet(e) {
  const action = (e.parameter.action || '').trim();
  try {
    _bootstrapSheets();
    if (action === 'ping') {
      return _respond({ ok: true, now: new Date().toISOString() });
    }

    if (action === 'login') {
      const email = (e.parameter.email || '').toLowerCase().trim();
      const password = (e.parameter.password || '').trim();
      const sh = _getSheet('Users');
      const headers = _headers(sh);
      const list = _rows(sh).map(r => _indexByHeader(r, headers));
      const found = list.find(u => String(u.email||'').toLowerCase() === email);
      if (!found) return _respond({ error: 'User not found' });
      
      // Verify password (you can add hashing here for security)
      if (password && String(found.password || '') !== '') {
        // Hash the input password to compare with stored hash
        const hashedInput = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password));
        if (hashedInput !== String(found.password || '')) {
          return _respond({ error: 'Invalid password' });
        }
      }
      // Normalize role, classes and subjects.  Support both lowercase
      // field names (roles, classes, subjects) and the singular/Title case
      // versions used in some spreadsheets (Role, Class, Classes, Subject, Subjects).
      const roleStr = (found.roles || found.role || '').toString();
      const roles = roleStr.split(',').map(s => s.trim()).filter(Boolean);
      const classStr = (found.classes || found.Class || found.Classes || '').toString();
      const classes = classStr.split(',').map(s => s.trim()).filter(Boolean);
      const subjStr = (found.subjects || found.Subject || found.Subjects || '').toString();
      const subjects = subjStr.split(',').map(s => s.trim()).filter(Boolean);
      const classTeacherFor = found.classTeacherFor || found['Class Teacher For'] || '';
      return _respond({ 
        name: found.name || '',
        email: found.email || '',
        roles,
        classes,
        subjects,
        classTeacherFor
      });
    }

    // Fallback GET handler for googleLogin (primarily for troubleshooting / legacy).
    // Prefer POST for security, but allow GET with idToken parameter so the
    // client can retry when POST returns 404 (e.g. stale deployment without doPost).
    if (action === 'googleLogin' && e.parameter.idToken) {
      return _handleGoogleLogin({ idToken: e.parameter.idToken });
    }

    if (action === 'getTeacherWeeklyTimetable') {
      // Weekly timetable: map the upcoming 7 calendar days to their day names
      // and return periods based on the dayOfWeek column.  Because the timetable
      // repeats weekly, we do not store specific dates in the sheet.  Instead,
      // we compute the day name (e.g. Monday) for each of the next seven days
      // starting from today and fetch matching rows for the logged‑in teacher.
      // Accept either teacher email or display name as the identifier.
      const identifier = (e.parameter.email || '').toLowerCase().trim();
      const days = [];
      const today = new Date();
      for (let i = 0; i < 7; i++) {
        const d = new Date(today.getTime() + i * 24 * 3600 * 1000);
        const iso = Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy-MM-dd');
        const dayName = Utilities.formatDate(d, Session.getScriptTimeZone(), 'EEEE');
        days.push({ date: iso, dayName });
      }
      const sh = _getSheet('Timetable');
      const headers = _headers(sh);
      const list = _rows(sh)
        .map(r => _indexByHeader(r, headers))
        .filter(r => {
          const te = String(r.teacherEmail || '').toLowerCase();
          const tn = String(r.teacherName || '').toLowerCase();
          return identifier && (te === identifier || tn === identifier);
        });
      const grouped = days.map(({ date, dayName }) => {
        const normalizedDay = _normalizeDayName(dayName);
        const periods = list
          .filter(x => _normalizeDayName(String(x.dayOfWeek || '')) === normalizedDay)
          .map(x => ({
            period: Number(x.period),
            class: String(x.class || ''),
            subject: String(x.subject || ''),
            teacherName: String(x.teacherName || '')
          }))
          .sort((a, b) => a.period - b.period);
        return { day: dayName, date, periods };
      });
      return _respond(grouped);
    }

    if (action === 'getTeacherDailyTimetable') {
      // Daily timetable for weekly schedule: compute the day name from the
      // provided date (or today) and return all periods matching that dayOfWeek.
      // Accept either teacher email or display name as the identifier.
      // ALSO include substitution assignments where this teacher is the substitute.
      const identifier = (e.parameter.email || '').toLowerCase().trim();
      const date = (e.parameter.date || _todayISO()).trim();
      // Get the day name for the supplied date in the script's timezone.
      const dayName = _dayName(date);
      const sh = _getSheet('Timetable');
      const headers = _headers(sh);
      
      // Get regular timetable periods
      const regularPeriods = _rows(sh)
        .map(r => _indexByHeader(r, headers))
        .filter(r => {
          const te = String(r.teacherEmail || '').toLowerCase();
          const tn = String(r.teacherName || '').toLowerCase();
          const rowDay = _normalizeDayName(String(r.dayOfWeek || ''));
          return identifier && (te === identifier || tn === identifier) && rowDay === _normalizeDayName(dayName);
        })
        .map(x => ({
          period: Number(x.period),
          class: x.class,
          subject: x.subject,
          teacherName: x.teacherName || '',
          isSubstitution: false
        }));
      
      // Get substitution assignments where this teacher is the substitute
      const subSh = _getSheet('Substitutions');
      const subHeaders = _headers(subSh);
      const substitutionPeriods = _rows(subSh)
        .map(r => _indexByHeader(r, subHeaders))
        .filter(r => {
          if (String(r.date || '') !== date) return false;
          const ste = String(r.substituteTeacher || '').toLowerCase();
          return identifier && (ste === identifier || ste.indexOf(identifier) !== -1);
        })
        .map(x => ({
          period: Number(x.period),
          class: String(x.class || ''),
          subject: String(x.substituteSubject || x.regularSubject || ''),
          teacherName: String(x.substituteTeacher || ''),
          isSubstitution: true,
          absentTeacher: String(x.absentTeacher || ''),
          regularSubject: String(x.regularSubject || '')
        }));
      
      // Combine regular and substitution periods, sort by period
      const allPeriods = [...regularPeriods, ...substitutionPeriods].sort((a, b) => a.period - b.period);
      
      return _respond(allPeriods);
    }

    // Additional actions handled by doGet continue below...
    // Keep all other GET handlers unchanged
    
    return _respond({ error: 'Unknown action' });
  } catch (err) {
    return _respond({ error: String(err && err.message ? err.message : err) });
  }
}

/**
 * Exchange Google ID token for application user profile/roles.
 * Expects payload: { idToken }
 * Validates token via Google tokeninfo endpoint, then maps email to Users sheet.
 */
function _handleGoogleLogin(payload) {
  if (!payload || !payload.idToken) {
    return _respond({ error: 'Missing idToken' });
  }
  try {
    const url = 'https://oauth2.googleapis.com/tokeninfo?id_token=' + encodeURIComponent(payload.idToken);
    const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    if (resp.getResponseCode() !== 200) {
      return _respond({ error: 'Invalid Google token' });
    }
    const info = JSON.parse(resp.getContentText());
    const verified = String(info.email_verified || info.emailVerified || '').toLowerCase();
    if (verified !== 'true') {
      return _respond({ error: 'Email not verified' });
    }
    const email = String(info.email || '').toLowerCase().trim();
    if (!email) {
      return _respond({ error: 'Token missing email' });
    }
    // OPTIONAL: domain restriction example
    // if (!email.endsWith('@yourdomain.com')) {
    //   return _respond({ error: 'Domain not allowed' });
    // }

    // Lookup user in Users sheet
    const sh = _getSheet('Users');
    const headers = _headers(sh);
    const list = _rows(sh).map(r => _indexByHeader(r, headers));
    const found = list.find(u => String(u.email || '').toLowerCase() === email);
    if (!found) {
      return _respond({ error: 'User not registered' });
    }

    // Normalize roles/classes/subjects similarly to login doGet
    const roleStr = (found.roles || found.role || '').toString();
    const roles = roleStr.split(',').map(s => s.trim()).filter(Boolean);
    const classStr = (found.classes || found.Class || found.Classes || '').toString();
    const classes = classStr.split(',').map(s => s.trim()).filter(Boolean);
    const subjStr = (found.subjects || found.Subject || found.Subjects || '').toString();
    const subjects = subjStr.split(',').map(s => s.trim()).filter(Boolean);
    const classTeacherFor = found.classTeacherFor || found['Class Teacher For'] || '';

    return _respond({
      email,
      name: found.name || info.name || '',
      roles,
      classes,
      subjects,
      classTeacherFor,
      picture: info.picture || ''
    });
  } catch (err) {
    return _respond({ error: 'googleLogin failed: ' + (err && err.message ? err.message : err) });
  }
}

/**
 * Handle POST actions (mutations and secure exchanges)
 */
function doPost(e) {
  const action = (e.parameter.action || '').trim();
  const data = _parsePost(e);
  try {
    _bootstrapSheets();
    
    // Handle Google login via POST
    if (action === 'googleLogin') {
      return _handleGoogleLogin(data);
    }
    
    if (action === 'submitPlan') {
      const sh = _getSheet('Schemes');
      _ensureHeaders(sh, SHEETS.Schemes);
      const now = new Date().toISOString();
      const schemeId = _uuid();
      const line = [
        schemeId,
        (data.email||'').toLowerCase().trim(),
        data.teacherName || '',
        data.class || '',
        data.subject || '',
        Number(data.term||0),
        Number(data.unit||0),
        data.chapter || '',
        data.month || '',
        Number(data.noOfSessions||0),
        'Pending',
        now
      ];
      sh.appendRow(line);
      return _respond({ submitted: true });
    }

    if (action === 'updatePlanStatus') {
      const { schemeId, status } = data;
      const sh = _getSheet('Schemes');
      const headers = _headers(sh);
      const idIdx = headers.indexOf('schemeId');
      const statusIdx = headers.indexOf('status');
      const nameIdx = headers.indexOf('teacherName');
      const emailIdx = headers.indexOf('teacherEmail');
      const classIdx = headers.indexOf('class');
      const subjectIdx = headers.indexOf('subject');
      const chapterIdx = headers.indexOf('chapter');
      const sessionsIdx = headers.indexOf('noOfSessions');

      const last = sh.getLastRow();
      if (last < 2) return _respond({ error: 'Not found' });
      const values = sh.getRange(2,1,last-1,headers.length).getValues();
      for (let i=0;i<values.length;i++) {
        if (String(values[i][idIdx]) === schemeId) {
          // Update this row
          const rowNum = i+2;
          sh.getRange(rowNum, statusIdx+1).setValue(status);
          // If approved, prepare for lesson plan population
          if (status === 'Approved') {
            const lpSh = _getSheet('LessonPlans');
            _ensureHeaders(lpSh, SHEETS.LessonPlans);
            const sessions = Number(values[i][sessionsIdx] || 1);
            const now = new Date().toISOString();
            for (let s=1;s<=sessions;s++) {
              const lpId = _uuid();
              lpSh.appendRow([
                lpId,
                values[i][emailIdx],
                values[i][nameIdx],
                values[i][classIdx],
                values[i][subjectIdx],
                values[i][chapterIdx],
                s, // session
                '', // objectives
                '', // activities
                'Pending', // status
                '', // reviewer remarks
                '', // date
                now
              ]);
            }
          }
          return _respond({ updated: true });
        }
      }
      return _respond({ error: 'Scheme not found'});
    }

    // Additional POST actions would continue here
    // All POST handlers should be in this function
    
    return _respond({ error: 'Unknown POST action' });
  } catch (err) {
    return _respond({ error: String(err && err.message ? err.message : err) });
  }
}

// Rest of your Apps Script functions go here
// Your file contains many more methods that I haven't included in this example